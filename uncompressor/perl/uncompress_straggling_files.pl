#!/usr/local/bin/perl
#  Copyright 2012, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# This function is a special function to uncompress any files that have previously been moved from the original source to scratch
# directory but the job that moved it there had died.  It is meant to be call at the end of the modis_level2_uncompressor() function.
# Some of the functionalities is similar to the modis_level2_uncompressor() function but differ slightly.
#
# Program will crawl a given directory and uncompress any .bz2 files it finds.  It will read the "Processing Version" attribute to determine if it is quicklook
# or refined and move the file to the appropriate bucket.  There should be 2 input buckets and 4 output buckets:
#
# Input buckets:
#
#    MODIS_AQUA_L2_SST_OBPG
#    MODIS_TERRA_L2_SST_OBPG
#
# Output buckets:
#
#    MODIS_AQUA_L2_SST_OBPG_QUICKLOOK
#    MODIS_AQUA_L2_SST_OBPG_REFINED
#    MODIS_TERRA_L2_SST_OBPG_QUICKLOOK
#    MODIS_TERRA_L2_SST_OBPG_REFINED
#
# The bucket's name is determined by appending to the variable i_modis_search_directory either "_QUICKLOOK" or "_REFINED".  The i_modis_search_directory
# is one of these:
#
#    MODIS_AQUA_L2_SST_OBPG
#    MODIS_TERRA_L2_SST_OBPG
#
#------------------------------------------------------------------------------------------------

# Location of GHRSST Perl library functions.

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/actualize_directory.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/crawl_sst_sst4_directories.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_quicklook_or_refined.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/ghrsst_notify_operator.pl";

use File::Basename;
use File::Copy;

my $NUM_FILES_TO_PROCESS = 10;  # Default number of files to process.  Will reset to smaller number if input is smaller.
$g_routine_name = "uncompress_straggling_files";

#------------------------------------------------------------------------------------------------------------------------
sub uncompress_straggling_files {
    # Set the input retrieved from command line.

    my $i_datatype          = shift;  # Always "sea_surface_temperature".
    my $i_datasource        = shift;  # The data sources are: {MODIS_A,MODIS_T}
    my $i_processing_type   = shift;  # Processing types are: {AQUA_QUICKLOOK, TERRA_QUICKLOOK, AQUA_REFINED, TERRA_REFINED} all uppercase.
    my $i_modis_search_directory     = shift;
    my $i_modis_data_name_prefix     = shift; 
    my $i_num_files_to_uncompress    = shift; 
    my $i_modis_output_directory     = shift;

    # Some time related business.

    my $begin_processing_time = localtime;
    log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");

    # Some variables related to sigevent.

    my $sigevent_type = "information";
    my $sigevent_msg = "hello there";
    my $sigevent_email_to = "DUMMY_EMAIL";
    my $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
    if ($sigevent_url eq '') {
        print "You must defined the sigevent URL: i.e. setenv GHRSST_SIGEVENT_URL http://lanina.jpl.nasa.gov:8100\n"; 
        die ("Cannot continue until environment GHRSST_SIGEVENT_URL is defined"); 
    }

    my $sigevent_clause = "SIGEVENT=" . $sigevent_url . "&category=UNCATEGORIZED&provider=jpl";
    my $temp_dir = "/tmp/";
    my $msg2report = 7;
    my $sigevent_data = '';

    # Time related variables used to keep track of how long things take.

    my $program_time_start = time();
    my $current_time = $program_time_start;

    my $log_type      = ""; 
    my $log_message   = ""; 

    # Crawl for a list of files in input directory.

    my $time_start_crawling = time();
    log_this("INFO",$g_routine_name,"BEGIN_CRAWLING $i_modis_search_directory"); 

    my $scratch_area = $ENV{SCRATCH_AREA};
    my $l_actualize_status = actualize_directory($scratch_area);
    $i_datatype = ""; 
    my ($status,$file_list_ref) = crawl_sst_sst4_directories($i_datatype,$i_datasource,$i_processing_type,$i_modis_search_directory,$i_modis_data_name_prefix);

    log_this("INFO",$g_routine_name,"CRAWL_STAGE  " . scalar(@$file_list_ref) . " CRAWL_DIRECTORY " . $i_modis_search_directory); 

    my $time_end_crawling = time();
    my $time_spent_in_crawling = $time_end_crawling - $time_start_crawling; 

    my @sst_sst4_filelist = @$file_list_ref; 

    my $num_sst_sst4_files = scalar(@sst_sst4_filelist);

    # Return if there's nothing to do.
    if ($num_sst_sst4_files == 0) {
        my $end_processing_time = localtime;
        log_this("INFO",$g_routine_name,"NO_FILES_FOUND $i_modis_search_directory");
        log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");
        log_this("INFO",$g_routine_name,"END_PROCESSING_TIME   $end_processing_time");
        return;
    }

    log_this("INFO",$g_routine_name,"FILTER_STAGE " . $num_sst_sst4_files . " $i_modis_search_directory"); 

    # Everything is OK, we can proceed with the decompression task.

    my $index_to_sst_sst4_list = 0;
    my $i_sst_filename = "";
    my $sst_filename_compressed_file = "";

    my $num_files_read                  = 0;
    my $num_uncompressed_files_created  = 0;
    my $time_spent_in_uncompressing     = 0; 
    my $time_spent_in_deciphering_quicklook_refined = 0; 
    my $time_spent_in_moving_to_destination         = 0; 
    my $total_Bytes_in_files        = 0; 
    my $total_Bytes_created_files   = 0; 
    my $name_only = "";

    # Reset the number of files to process if input is smaller.

    if ($i_num_files_to_uncompress <= $NUM_FILES_TO_PROCESS) {
        $NUM_FILES_TO_PROCESS = $i_num_files_to_uncompress;
    }

    # For every name found, send it to be uncompressed.

    while (($index_to_sst_sst4_list < $num_sst_sst4_files) && ($num_uncompressed_files_created < $NUM_FILES_TO_PROCESS)) {

        $sst_filename_compressed_file  = $sst_sst4_filelist[$index_to_sst_sst4_list]; 

        # Remove the carriage return

        chomp ($sst_filename_compressed_file);
 
        # Note:  Even if the file has already been compressed, it will be moved to its final destination.

        log_this("INFO",$g_routine_name,($num_uncompressed_files_created + 1) . " OUT_OF " . $num_sst_sst4_files . " PROCESSING_GRANULE $sst_filename_compressed_file");

        #
        # Get the size of this file.
        #

        my $size_of_sst_file_in_bytes  = (stat($sst_filename_compressed_file))[7];
        log_this("INFO",$g_routine_name,"ORIGINAL_FILE $sst_filename_compressed_file");
        $total_Bytes_in_files += $size_of_sst_file_in_bytes; 

        # Get the age of the file so we can report it.

        my $time_now = time();
        my $minutes_difference_between_sst_and_now = 0;
        my $last_modified_time_of_sst              =  (stat($sst_filename_compressed_file))[9];  # Get last modified time in seconds since 1970
        my $seconds_difference_between_sst_and_now = $time_now - $last_modified_time_of_sst;
        $minutes_difference_between_sst_and_now = sprintf("%.0f",$seconds_difference_between_sst_and_now/60);

        # Set the scratch area for decompression to the same directory as the compressed file so the move later to the _QUICKLOOK or _REFINED directory won't be costly.

        #my $decompress_to_directory = dirname($sst_filename_compressed_file);  # Having problem with this, moving back to scratch_area variable.
        my $decompress_to_directory = $scratch_area;
        log_this("INFO",$g_routine_name,"DECOMPRESS_TO_DIRECTORY $decompress_to_directory FILE $sst_filename_compressed_file");

        # Uncompressed the file.

        my $time_start_uncompress = time();

        # Status returned: 0 good, 1 bad.

        my ($status,$i_sst_filename)  = perform_straggling_uncompression($sst_filename_compressed_file,$i_processing_type,$decompress_to_directory);

        if ($status == 1) {
            $sigevent_type = "error";
            $sigevent_msg = "File $sst_filename_compressed_file is either not found or may be corrupted.";
            $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);

            $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
            log_this("ERROR",$g_routine_name,$sigevent_msg);
            next;
        }

        log_this("INFO",$g_routine_name,"UNCOMPRESSED_FILE $i_sst_filename");
        if (!(-e $i_sst_filename)) {
            log_this("WARN",$g_routine_name,"UNCOMPRESSED_FILE_NOT_FOUND $i_sst_filename");
        }

        #
        # Get the size of this file.
        #

        my $size_of_uncompressed_file_in_bytes  = (stat($i_sst_filename))[7];
        $total_Bytes_created_files   += $size_of_uncompressed_file_in_bytes; 

        # Keep track of how many files we have read.
        $num_files_read += 1;

        my $time_end_uncompress = time();
        $time_spent_in_uncompressing += ($time_end_uncompress - $time_start_uncompress); 

        # Since we cannot determine if the file is quicklook or refined just from the filename, we have to open up the uncompressed file and read the "Processing Version" attribute.
        # Once that is known, we can move the file to its final location.

        my $time_start_deciphering = time();
        my $quicklook_or_refined_flag = is_granule_quicklook_or_refined($i_sst_filename);
        my $time_end_deciphering = time();
        $time_spent_in_deciphering_quicklook_refined += ($time_end_deciphering - $time_start_deciphering); 

        #
        # Build the output file name by adding the value in quicklook_or_refined_flag variable.
        #

        # First remove the directory name of the input file and just get the file name.

        my @splitted_tokens = split(/\//,$i_sst_filename);
        my $num_tokens = @splitted_tokens;
        $name_only = $splitted_tokens[$num_tokens-1];  # Get just the name.   We assume the name is the last token.

        my $upper_level_output_directory = strip_trailing_slash($i_modis_output_directory) . '_' . $quicklook_or_refined_flag;  # We add _QUICKLOOK or _REFINED to the directory name.

        # Create the directory if it does not exist yet.
        if (!(-e $upper_level_output_directory)) {
            mkdir($upper_level_output_directory);
        }

        # Now we can create our output name with its proper bucket.

        my $out_filename  = $upper_level_output_directory . "/" . $name_only;

        $log_message = "FILE_SIZE " . $size_of_uncompressed_file_in_bytes . " " . $i_sst_filename . " " . "FILE_AGE " . $minutes_difference_between_sst_and_now;
        log_this("INFO",$g_routine_name,$log_message);

        $log_message = "FILE_TYPE $quicklook_or_refined_flag $i_sst_filename"; 
        log_this("INFO",$g_routine_name,$log_message);

        #
        # Finally, we can move the file to its proper location.
        #

        my $time_start_moving = time();

        # There are 2 ways to move the file.  One is to use the File::Copy module with the move() function.
        # The other method is to use the system mv command.  Both does take time.

        $log_message = "FILE_MOVE $i_sst_filename $out_filename";

        if (2 == 2) {
            # Only move the file back to its original source if its age is older than the threshold to give
            # any jobs associated with it to have a chance to finish.
            # Remember that the file is now sitting in a scratch directory (either uncompressed or compressed).  It got there
            # because a script had moved it there from the original source to scratch to be uncompressed and the job may have died.
            # If it has been sitting there for some time, set by variable THRESHOLD_OF_STRAGGLER_FILES, then it can be moved to its intended destination.

            my $THRESHOLD_OF_STRAGGLER_FILES = 50;  # If a file is older than this number of minutes, we can move it back to its source.
            if ($minutes_difference_between_sst_and_now > $THRESHOLD_OF_STRAGGLER_FILES) {
                # Use the module File::Copy to do the move.
                move($i_sst_filename,$out_filename);
                log_this("INFO",$g_routine_name,$log_message);
                $log_message = "UNCOMPRESSED_FILE_CREATED " . $out_filename; 
                log_this("INFO",$g_routine_name,$log_message);
                $num_uncompressed_files_created += 1;
            } else {
                $log_message = "FILE_NAME $i_sst_filename FILE_AGE $minutes_difference_between_sst_and_now LESS_THAN_THRESHOLD $THRESHOLD_OF_STRAGGLER_FILES MINUTES_LEAVE_FILE_ALONE $i_sst_filename";
                log_this("INFO",$g_routine_name,$log_message);
            }
        } else {
            # This method can move across devices but cost is in the system() command.
            system("mv $i_sst_filename $out_filename");
            $log_message = "UNCOMPRESSED_FILE_CREATED " . $out_filename; 
            log_this("INFO",$g_routine_name,$log_message);
            $num_uncompressed_files_created += 1;
        }
        my $time_end_moving = time();
        $time_spent_in_moving_to_destination += ($time_end_moving - $time_start_moving); 

        if ($g_debug) { log_this("DEBUG",$g_routine_name,"mv $i_sst_filename $out_filename"); }

        # Do one last sanity check if the file was neither QUICKLOOK nor REFINED, we raise a sigevent.

        if (($quicklook_or_refined_flag ne "QUICKLOOK") && ($quicklook_or_refined_flag ne "REFINED")) {
            $sigevent_type = "error";
            $sigevent_msg = "File $i_sst_filename could not determine to be QUICKLOOK or REFINED.  Moved to $upper_level_output_directory directory.";
            $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
            log_this("ERROR",$g_routine_name,$sigevent_msg);
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
        }

        $index_to_sst_sst4_list         += 1;
    }

    my $program_time_end = time();
    my $elapsed_in_seconds = $program_time_end - $program_time_start;
    my $elapsed_in_minutes = sprintf("%.2f",($elapsed_in_seconds/60.0));

    # ---------- Close up shop ----------

    #
    # Variables related to disk space calculation.
    #

    my $Kilobyte_to_Byte_conversion_factor     = 1024;       # Kilobyte_const in Bytes
    my $Megabyte_to_Byte_conversion_factor     = 1048576;    # Megabyte_const in Bytes
    my $Gigabyte_to_Byte_conversion_factor     = 1073741824; # in Bytes
    my $Gigabyte_to_Megabyte_conversion_factor = 1024;       # in Megabyte

    my $total_Megabytes_in_files = $total_Bytes_in_files / $Megabyte_to_Byte_conversion_factor;
    my $total_Gigabytes_in_files = $total_Bytes_in_files / $Gigabyte_to_Byte_conversion_factor;

    # Print run statistics.

    #log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_crawling         $time_spent_in_crawling");
    log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_uncompress                    $time_spent_in_uncompressing");
    log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_deciphering_quicklook_refined $time_spent_in_deciphering_quicklook_refined");
    log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_moving_to_destination         $time_spent_in_moving_to_destination");
    log_this("INFO",$g_routine_name,"FILES_STAT Number_of_files_read             $num_files_read");
    log_this("INFO",$g_routine_name,"FILES_STAT total_Gigabytes_in_files         $total_Gigabytes_in_files");
    #log_this("INFO",$g_routine_name,"FILES_STAT Batch_size                       $NUM_FILES_TO_PROCESS");
    #log_this("INFO",$g_routine_name,"FILES_STAT Number_of_uncompressed_files_created $num_uncompressed_files_created");
    #log_this("INFO",$g_routine_name,"FILES_STAT total_Bytes_in_files             $total_Bytes_in_files");
    #log_this("INFO",$g_routine_name,"FILES_STAT total_Megabytes_in_files         $total_Megabytes_in_files");
    #
    my $total_Megabytes_created = $total_Bytes_created_files / $Megabyte_to_Byte_conversion_factor;
    my $total_Gigabytes_created = $total_Bytes_created_files / $Gigabyte_to_Byte_conversion_factor;

    #log_this("INFO",$g_routine_name,"FILES_STAT total_Bytes_created_files $total_Bytes_created_files");
    log_this("INFO",$g_routine_name,"FILES_STAT total_Megabytes_created   $total_Megabytes_created");
    log_this("INFO",$g_routine_name,"FILES_STAT total_Gigabytes_created   $total_Gigabytes_created");

    if ($num_uncompressed_files_created > 0) {
        my $average_processing_time = $elapsed_in_seconds / $num_uncompressed_files_created;
        log_this("INFO",$g_routine_name,"TIME_STAT Seconds_Average_Processing $average_processing_time");
    }

    #log_this("INFO",$g_routine_name,"TIME_STAT Seconds_Elapsed           $elapsed_in_seconds");
    #log_this("INFO",$g_routine_name,"TIME_STAT Minutes_Elapsed           $elapsed_in_minutes");

    my $end_processing_time = localtime;

    log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");
    log_this("INFO",$g_routine_name,"END_PROCESSING_TIME   $end_processing_time, $elapsed_in_seconds seconds");

}

# Test code only, comment out for operation.
if (2 == 3) {
my $i_datatype = "AQUA_REFINED";
my $i_datasource = "MODIS_A";
my $i_processing_type = "MODIS_A";
my $i_modis_search_directory = "/data/dev/scratch/qchau/scratch/AQUA_REFINED/";
my $i_modis_data_name_prefix = "A";
my $i_num_files_to_uncompress = 1;
my $i_modis_output_directory = "/data/dev/scratch/qchau/scratch/AQUA_REFINED";

    uncompress_straggling_files($i_datatype,
                                $i_datasource,
                                $i_processing_type,
                                $i_modis_search_directory,
                                $i_modis_data_name_prefix,
                                $i_num_files_to_uncompress,
                                $i_modis_output_directory);
}

#------------------------------------------------------------------------------------------------------------------------
sub perform_straggling_uncompression {
    # If the name contains .bz2, we will apply the bunzip2 program to it.
    # If it does not, we will simply perform a mv command.  Even if the file are mounted on different devices, the move will be successful.

    # Get input.

    my $i_compressed_filename               = shift;
    my $i_processing_type                   = shift;
    my $i_scratch_directory                 = shift;

    # Output variable(s).

    my $o_status = 0;
    my $o_uncompressed_filename = "";

    # Remove the directory name by splitting the name and get just the name.

    my @splitted_tokens = split(/\//,$i_compressed_filename);
    my $num_tokens = @splitted_tokens;
    my $name_only = $splitted_tokens[$num_tokens-1];  # Get just the name. 

    # We must check for existence of the uncompressed file. The program bunzip2 will not allow an overwrite.
    my $name_without_bz_extension = $name_only; 
    my $file_is_compressed_flag = 0;
    if ((rindex($name_only,".bz2")) >= 0) {
        $name_without_bz_extension = substr($name_only,0,-4);  # Get everything up to and not include the .
        $file_is_compressed_flag = 1;
    }

    # Based on the processing type, we will figure where to either uncompress or move the file to.

    my $upper_level_output_directory = "$i_scratch_directory/$i_processing_type";

    # Create the directory if it does not exist yet.
    if (!(-e $upper_level_output_directory)) {
        mkdir($upper_level_output_directory);
    }

    $o_uncompressed_filename = "$upper_level_output_directory/$name_without_bz_extension";

    if (($file_is_compressed_flag == 1) && (-e "$o_uncompressed_filename")) {
        print "perform_decompression_task: Removing existing file [$o_uncompressed_filename]\n";
        unlink "$o_uncompressed_filename";
    }

    if ($file_is_compressed_flag == 1)  {
        my $call_system_command_str = "";

        # Do the uncompression.

        $call_system_command_str = "/usr/bin/bunzip2 $i_compressed_filename";
#        log_this("DEBUG",$g_routine_name,"system [$call_system_command_str]");

        system("$call_system_command_str");

        #
        # Check for errors.
        #
        if ($? == -1) {
#            print "perform_decompression_task: system [$call_system_command_str] failed to execute: $?\n";
            log_this("ERROR",$g_routine_name,"system [$call_system_command_str] failed to execute: $?");
            $o_status = 1;
        } elsif ($? == 256){
#            print "perform_decompression_task: Cannot find file $i_compressed_filename or $upper_level_output_directory/$name_only\n";
            log_this("ERROR",$g_routine_name,"Cannot find file $i_compressed_filename");
            $o_status = 1;
        } elsif ($? == 0){
            $o_status = 0;
            log_this("INFO",$g_routine_name,"FILE_UNCOMPRESSED $o_uncompressed_filename");
        } else {
#            print "perform_decompression_task: system [$call_system_command_str] executed with: $?\n";
            log_this("ERROR",$g_routine_name,"system [$call_system_command_str] executed with: $?");
            $o_status = 1;

            # Since we cannot uncompress this file, it may be corrupted.
            # We need to move it to a quarantine directory for the operator to inspect.
            # A sigevent should be raised when the variable o_status is returned with the value of 1.

            my $quarantine_directory = "$i_scratch_directory/quarantine";

            # Create the directory if it does not exist yet.
            if (!(-e $quarantine_directory)) {
                mkdir($quarantine_directory);
            }
            # Use the module File::Copy to do the move.
            move($i_compressed_filename,$quarantine_directory);
            log_this("ERROR",$g_routine_name,"FILE_MOVE $i_compressed_filename $quarantine_directory");
        }

    } else {
        $o_uncompressed_filename = $i_compressed_filename;  # The file was not compressed at all, we set the output name to the input name.
        log_this("INFO",$g_routine_name,"ORIGINAL_FILE_IS_UNCOMPRESSED_ALREADY $o_uncompressed_filename");
    }

    return ($o_status,$o_uncompressed_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub strip_trailing_slash {
    # If a name ends with a slash, function will remove it.
    my $i_name = shift;

    my $o_stripped_name = $i_name; 

    # Get the last character from the input name.

    my $name_length = length($i_name);
    my $last_character = substr($i_name,($name_length-1));

    # If the name ends with a slash, get just up to the slash, not including.
    if ($last_character eq '/') { 
        $o_stripped_name = substr($i_name,0,$name_length-1); # Copy up to the '/' character.
    }
   return ($o_stripped_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}
