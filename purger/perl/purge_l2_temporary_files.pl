#!/usr/local/bin/perl

#  Copyright 2012, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Function purges temporary files from the MODIS L2 Combiner processing.
#
# The location of the temporary archive can be found in file ghrsst_data_config.in with the
# line MODIS_SEATMP_L2P_CORE_DIRECTORY string.
#
# This function makes a distinction from which directory to purge based on the value of variable
# i_dataset_name, whether it is MODIS_A for Aqua for MODIS_T for Terra.
#
#------------------------------------------------------------------------------------------------

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

$GHRSST_DATA_CONFIG_FILE = "";

do "$GHRSST_PERL_LIB_DIRECTORY/load_ghrsst_run_config.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/get_ghrsst_config.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/crawl_sst_sst4_directories.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/actualize_directory.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/log_this.pl";

use File::Basename;

sub purge_l2_temporary_files {

    my $begin_processing_time = localtime;
    print "\n";
    print "purge_l2_temporary_files: begin_processing_time = $begin_processing_time\n";

    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input: 
    #

    my $i_dataset_name                  = $_[0];   # MODIS_A or MODIS_T
    my $i_processing_type               = $_[1];   # Possible values are AQUA_QUICKLOOK, AQUA_REFINED, TERRA_QUICKLOOK or TERRA_REFINED
    my $i_num_days_to_keep              = $_[2];
    my $i_perform_disk_space_count_only = $_[3];

    $GHRSST_DATA_CONFIG_FILE = $ENV{GHRSST_DATA_CONFIG_FILE};

    # Load in configuration first.

    my $l_status = load_ghrsst_run_config($GHRSST_DATA_CONFIG_FILE);

    #
    # Local variables.
    #

    my $file_search_directory = "DUMMY";
    my $year_search_directory = "DUMMY";
    my $doy_search_directory  = "DUMMY";

    my $l2p_core_archive_directory = ""; 
    my $scratch_area               = $ENV{SCRATCH_AREA};
    $l_actualize_status = actualize_directory($scratch_area);

    # Make a random number used in creating unique file names.
    my $random_number_suffix = int(rand(10000));

    my $tstr = "purging_l2p_core" . "_";  # Temporary type string with underscore.

    my $modis_data_name_prefix = "";
    my $modis_search_directory = "";

    # Set the input retrieved from command line.

    my $i_datatype          = "sea_surface_temperature";
    my $i_datasource        = uc($i_dataset_name);

    my $log_type      = "";
    my $function_name = $g_routine_name;
    my $log_message   = "";

    # Get the directory to crawl and prefix to look for.

    my $modis_search_directory = "";
    my $modis_data_name_prefix = "";

    if ($i_processing_type eq "AQUA_QUICKLOOK") {
            $modis_search_directory = get_ghrsst_config("AQUA_QUICKLOOK");
            $modis_data_name_prefix = "A";
    } elsif ($i_processing_type eq "TERRA_QUICKLOOK") {
            $modis_search_directory = get_ghrsst_config("TERRA_QUICKLOOK");
            $modis_data_name_prefix = "T";
    } elsif ($i_processing_type eq "VIIRS_QUICKLOOK") {
            $modis_search_directory = get_ghrsst_config("VIIRS_QUICKLOOK");
            $modis_data_name_prefix = "S";
    } elsif ($i_processing_type eq "AQUA_REFINED") {
            $modis_search_directory = get_ghrsst_config("AQUA_REFINED");
            $modis_data_name_prefix = "A";
    } elsif ($i_processing_type eq "TERRA_REFINED") {
            $modis_search_directory = get_ghrsst_config("TERRA_REFINED");
            $modis_data_name_prefix = "T";
    } elsif ($i_processing_type eq "VIIRS_REFINED") {
            $modis_search_directory = get_ghrsst_config("VIIRS_REFINED");
            $modis_data_name_prefix = "S";
    } else {
            die("purge_l2_temporary_files:ERROR: Does recognize processing type [$i_processing_type]");
    }

    # Now, we have the hot directory to crawl, we can crawl for a list of files to process.

    my $time_start_crawling = time();
    log_this("INFO",$g_routine_name,"BEGIN_CRAWLING $modis_search_directory");

    my $optional_days_back = 365;  # Get files since a year ago.  This should cover test files placed there by the developer or tester.
    my ($status,$file_list_ref) = crawl_sst_sst4_directories($i_datatype,$i_datasource,$i_processing_type,$modis_search_directory,$modis_data_name_prefix,$optional_days_back);

    log_this("INFO",$g_routine_name,"CRAWL_STAGE " . scalar(@$file_list_ref) . " CRAWL_DIRECTORY " . $modis_search_directory);

    my $time_end_crawling = time();
    my $time_spent_in_crawling = $time_end_crawling - $time_start_crawling;

    my @modis_filelist= @$file_list_ref;

    #
    # Note: all time related variables in this function are in seconds.
    #
    # Convert the days to seconds to be used in comparison.
    # Multiply by 24 hours in a day, 60 minutes in an hour, and 60 seconds in a minute.
    #
 
    my $num_seconds_to_keep = $i_num_days_to_keep * 24.0 * 60.0 * 60.0;

    my $num_files_in_archive = @modis_filelist;
    my $num_files_expired    = 0;
    my $time_now_in_epoch = time;

    #
    # Variables related to disk space calculation.
    #

    my $Kilobyte_to_Byte_conversion_factor     = 1024;       # Kilobyte_const in Bytes
    my $Megabyte_to_Byte_conversion_factor     = 1048576;    # Megabyte_const in Bytes
    my $Gigabyte_to_Byte_conversion_factor     = 1073741824; # in Bytes
    my $Gigabyte_to_Megabyte_conversion_factor = 1024;       # in Megabyte 

    my $total_Bytes_expired = 0.0;      # Used in keep track of how much space has been re-claimed. 
    my $total_Megabytes_expired = 0.0;  # This is in Megabyte or 1048576 Bytes 
    my $total_Gigabytes_expired = 0.0;  # This is in Gigabyte or 1073741824 Bytes 

    #
    # Check each file to see if it's older than the given number of days to keep.  If it's older,
    # then we delete it.
    #

    my $seconds_difference = 0; 
    my $minutes_difference = 0; 
    my $hours_difference   = 0; 
    my $days_difference    = 0; 

    my $name_to_delete = "";

    for ($dataset_to_process_index = 0; $dataset_to_process_index < $num_files_in_archive; $dataset_to_process_index++) {

        # Remove the carriage return.

        chomp($modis_filelist[$dataset_to_process_index]);
        $name_to_delete = $modis_filelist[$dataset_to_process_index];

        #
        # Get the statistic of this file.  The index [9] contains the mtime: last modify time
        # in seconds since the epoch time.
        #

        my $last_modify_time_in_epoch = (stat($name_to_delete))[9];

        $seconds_difference = $time_now_in_epoch - $last_modify_time_in_epoch;
        $minutes_difference = sprintf("%.0f",$seconds_difference/60);
        $hours_difference   = sprintf("%.0f",$seconds_difference/3600);
        $days_difference    = sprintf("%.0f",$seconds_difference/(3600*24));

        # Check to see the file creation date is more than the number of days to keep.

        if ($last_modify_time_in_epoch < ($time_now_in_epoch - $num_seconds_to_keep)) {
            # Regardless if we are deleting this file or not, this count gets incremented.

            $num_files_expired++;

            #
            # Get the size of this file and sum up space re-claimed in bytes.
            #

            my $size_of_file_in_bytes = (stat($name_to_delete))[7];
            $total_Bytes_expired += $size_of_file_in_bytes; 

            #
            # Expire this file if creation date is passed what we want.
            #

            if ($i_perform_disk_space_count_only eq "yes") {
                # Do nothing.  This is only to count how much space will be re-claimed without
                # actually deleting the files.
                if ($g_debug) {
                    if (-f $name_to_delete) {
                        log_this("INFO",$g_routine_name,"FILE_AGE_IN_DAYS $days_difference FILE_SIZE $size_of_file_in_bytes FILE_NAME " . $name_to_delete);
                    } else {
                        log_this("INFO",$g_routine_name,"FILE_AGE_IN_DAYS $days_difference FILE_SIZE $size_of_file_in_bytes DIRECTORY_NAME " . $name_to_delete);
                    }
                }
            } elsif ($i_perform_disk_space_count_only eq "no") {
                # Only remove file and not directory.
                if (-f $name_to_delete) {
                    unlink($name_to_delete);
                    log_this("INFO",$g_routine_name,"FILE_AGE_IN_DAYS $days_difference FILE_SIZE $size_of_file_in_bytes FILE_REMOVED " . $name_to_delete);
                    # Remove the parent directory if empty.
                    remove_directory_if_empty($name_to_delete,$modis_search_directory);
                }

            } else {
                print "purge_l2_temporary_files: WARNING, Unrecognized value for i_perform_disk_space_count_only = $i_perform_disk_space_count_only\n";
            }
        }
    }

    # Convert space re-claimed from byte to Megabyte and Gigabyte.

    if ($num_files_expired > 0) {
        $total_Megabytes_expired = $total_Bytes_expired / $Megabyte_to_Byte_conversion_factor;
        $total_Gigabytes_expired = $total_Bytes_expired / $Gigabyte_to_Byte_conversion_factor;
    }

    #
    # Print processing stats.
    #

    my $end_processing_time = localtime;
    log_this("INFO",$g_routine_name,"");
    log_this("INFO",$g_routine_name,"num_files_in_archive    = $num_files_in_archive");
    log_this("INFO",$g_routine_name,"i_num_days_to_keep      = $i_num_days_to_keep");

    log_this("INFO",$g_routine_name,"");

    if ($i_perform_disk_space_count_only eq "yes") {
        log_this("INFO",$g_routine_name,"Performed disk space reclaimed count only.  No files were purged from disk.");
    } elsif ($i_perform_disk_space_count_only eq "no") {
        log_this("INFO",$g_routine_name,"Actual statistics of disk space reclaimed.");
    }
    log_this("INFO",$g_routine_name,"");

    log_this("INFO",$g_routine_name,"num_files_expired       = $num_files_expired");
    log_this("INFO",$g_routine_name,"total_Bytes_expired     = $total_Bytes_expired");
    log_this("INFO",$g_routine_name,"total_Megabytes_expired = $total_Megabytes_expired");
    log_this("INFO",$g_routine_name,"total_Gigabytes_expired = $total_Gigabytes_expired");

    log_this("INFO",$g_routine_name,"");
    log_this("INFO",$g_routine_name,"begin_processing_time = $begin_processing_time");
    log_this("INFO",$g_routine_name,"end_processing_time   = $end_processing_time");

    # ---------- Close up shop ----------
    return ($o_status);

}

#------------------------------------------------------------------------------------------------------------------------

# A few global variables.

$g_debug = 0;
$g_routine_name = "purge_l2_temporary_files";

my $i_datatype          = "sea_surface_temperature";
my $i_datasource        = "MODIS_A";
my $i_processing_type   = "AQUA_QUICKLOOK";
my $i_modis_search_directory = "";
my $i_modis_data_name_prefix = "A";

my $num_args = $#ARGV + 1;

# Do sanity check to make sure we have the correct number of parameters.

if ($num_args < 3 ) {
        print "usage: perl purge_l2_temporary_files.pl dataset_name processing_type num_days_to_keep perform_disk_space_count_only\n";
        print "usage: perl purge_l2_temporary_files.pl MODIS_A      AQUA_QUICKLOOK  10               no\n";
        print "usage: perl purge_l2_temporary_files.pl MODIS_A      AQUA_REFINED    10               no\n";
        print "usage: perl purge_l2_temporary_files.pl MODIS_T      TERRA_QUICKLOOK 10               no\n";
        print "usage: perl purge_l2_temporary_files.pl MODIS_T      TERRA_REFINED   10               no\n";
        exit(1);
}

# Get the input parameters.

# Set to default first and will get from argument list later.

my $i_dataset_name                  = "MODIS_A";
my $i_processing_type               = "AQUA_QUICKLOOK";
my $i_num_days_to_keep              = 50;
my $i_perform_disk_space_count_only = "no";

# Get the value from the command line.

$i_dataset_name      = $ARGV[0];
$i_processing_type   = $ARGV[1];
$i_num_days_to_keep  = $ARGV[2];
$i_perform_disk_space_count_only = "";

if ($ARGV[3] ne '') {
    $i_perform_disk_space_count_only= $ARGV[3];
}

# Check to see if we want to debug or not.
if ($ARGV[4] ne '') {
    if ($ARGV[4] eq 'yes') {
        $g_debug = 1;
    }
}

# Calls below subroutine to purge these temporary files.

purge_l2_temporary_files($i_dataset_name, 
                         $i_processing_type, 
                         $i_num_days_to_keep, 
                         $i_perform_disk_space_count_only);


#------------------------------------------------------------------------------------------------------------------------
sub strip_trailing_slash {
    # If a name ends with a slash, function will remove it.
    my $i_name = shift;

    my $o_stripped_name = $i_name;

    # Get the last character from the input name.

    my $name_length = length($i_name);
    my $last_character = substr($i_name,($name_length-1));

    # If the name ends with a slash, get just up to the slash, not including.
    if ($last_character eq '/') {
        $o_stripped_name = substr($i_name,0,$name_length-1); # Copy up to the '/' character.
    }
   return ($o_stripped_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub is_directory_empty {
    my $i_directory_to_check = shift;
    my $o_empty_flag = 0;  # Assume not empty.
    opendir(DIR,$i_directory_to_check) or do {
        return ($o_empty_flag);
    };
    readdir DIR; # reads .
    readdir DIR; # reads ..
    if (readdir DIR) { #now there should be a file or folder
#      print "it's not empty\n";
    } else {
#       print "it is empty\n";
        $o_empty_flag = 1;
    }
    close DIR;
    return ($o_empty_flag);
}

#------------------------------------------------------------------------------------------------------------------------
sub remove_directory_if_empty {
    my $last_file_deleted = shift;
    my $last_directory_crawled = shift;

    my $parent_directory = dirname($last_file_deleted);

    if (strip_trailing_slash($parent_directory) eq strip_trailing_slash($last_directory_crawled)) {
        # Do nothing, parent directory is the same as the directory we crawled.
     } else {
         my $empty_flag = is_directory_empty($parent_directory);
         if ($empty_flag == 1) {
             #rmdir ($parent_directory);
             log_this("INFO",$g_routine_name,"REMOVE_EMPTY_PARENT_DIRECTORY $parent_directory");
         }
     }
}
