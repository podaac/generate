#!/usr/local/bin/perl

#  Copyright 2012, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Function purges files in the temporary holding tank.  The holding tank is stored in
# a directory named holding_tank sub to the scratch disk.
#
#------------------------------------------------------------------------------------------------

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/actualize_directory.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/log_this.pl";

use File::Basename;

sub purge_l2_holding_tank {

    my $begin_processing_time = localtime;
    log_this("INFO",$g_routine_name,"begin_processing_time = $begin_processing_time");

    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input: 
    #

    my $i_num_minutes_to_keep           = shift;
    my $i_perform_disk_space_count_only = shift;

    #
    # Local variables.
    #

    my $scratch_area    = $ENV{SCRATCH_AREA};
    $l_actualize_status = actualize_directory($scratch_area);

    # Set the input retrieved from command line.

    my $log_type      = "";
    my $function_name = $g_routine_name;
    my $log_message   = "";

    my $output_file_name_wild_search = $scratch_area . "/holding_tank" . "/" . "*LAC*";

    # Change the pattern if user specified a different pattern.
    if ($ENV{FILE_PURGE_NAME_PATTERN} ne "") {
        $output_file_name_wild_search = $scratch_area . "/holding_tank" . "/" . $ENV{FILE_PURGE_NAME_PATTERN};
    }

    # Now, we have the hot directory to crawl, we can crawl for a list of files to process.

    my $time_start_crawling = time();
    log_this("INFO",$g_routine_name,"BEGIN_CRAWLING $scratch_area/holding_tank");


    my (@file_list) = glob($output_file_name_wild_search);
    my $num_names_found = @file_list;

    log_this("INFO",$g_routine_name,"CRAWL_STAGE " . $num_names_found . " CRAWL_DIRECTORY " . $output_file_name_wild_search);
#exit(0);

    my $time_end_crawling = time();
    my $time_spent_in_crawling = $time_end_crawling - $time_start_crawling;

    #
    # Note: all time related variables in this function are in seconds.
    #
    # Convert the minutes to seconds to be used in comparison.
    # Multiply by 60 seconds in a minute.
    #
 
    my $num_seconds_to_keep = $i_num_minutes_to_keep * 60.0;

    my $num_files_in_archive = @file_list;
    my $num_files_expired    = 0;
    my $time_now_in_epoch = time;

    #
    # Variables related to disk space calculation.
    #

    my $Kilobyte_to_Byte_conversion_factor     = 1024;       # Kilobyte_const in Bytes
    my $Megabyte_to_Byte_conversion_factor     = 1048576;    # Megabyte_const in Bytes
    my $Gigabyte_to_Byte_conversion_factor     = 1073741824; # in Bytes
    my $Gigabyte_to_Megabyte_conversion_factor = 1024;       # in Megabyte 

    my $total_Bytes_expired = 0.0;      # Used in keep track of how much space has been re-claimed. 
    my $total_Megabytes_expired = 0.0;  # This is in Megabyte or 1048576 Bytes 
    my $total_Gigabytes_expired = 0.0;  # This is in Gigabyte or 1073741824 Bytes 

    #
    # Check each file to see if it's older than the given number of days to keep.  If it's older,
    # then we delete it.
    #

    my $seconds_difference = 0; 
    my $minutes_difference = 0; 
    my $hours_difference   = 0; 
    my $days_difference    = 0; 

    my $name_to_delete = "";

    for ($dataset_to_process_index = 0; $dataset_to_process_index < $num_files_in_archive; $dataset_to_process_index++) {

        # Remove the carriage return.

        chomp($file_list[$dataset_to_process_index]);
        $name_to_delete = $file_list[$dataset_to_process_index];

        #
        # Get the statistic of this file.  The index [9] contains the mtime: last modify time
        # in seconds since the epoch time.
        #

        my $last_modify_time_in_epoch = (stat($name_to_delete))[9];

        $seconds_difference = $time_now_in_epoch - $last_modify_time_in_epoch;
        $minutes_difference = sprintf("%.0f",$seconds_difference/60);
        $hours_difference   = sprintf("%.0f",$seconds_difference/3600);

        # Check to see the file creation date is more than the number of days to keep.

        if ($last_modify_time_in_epoch < ($time_now_in_epoch - $num_seconds_to_keep)) {
            # Regardless if we are deleting this file or not, this count gets incremented.

            $num_files_expired++;

            #
            # Get the size of this file and sum up space re-claimed in bytes.
            #

            my $size_of_file_in_bytes = (stat($name_to_delete))[7];
            $total_Bytes_expired += $size_of_file_in_bytes; 

            #
            # Expire this file if creation date is passed what we want.
            #

            if ($i_perform_disk_space_count_only eq "yes") {
                # Do nothing.  This is only to count how much space will be re-claimed without
                # actually deleting the files.
            } elsif ($i_perform_disk_space_count_only eq "no") {
                # Only remove file and not directory.
                if (-f $name_to_delete) {
                    unlink($name_to_delete);
                    log_this("INFO",$g_routine_name,"FILE_AGE_IN_MINUTES $minutes_difference FILE_SIZE $size_of_file_in_bytes FILE_REMOVED " . $name_to_delete);
                }

            } else {
                print "purge_l2_holding_tank: WARNING, Unrecognized value for i_perform_disk_space_count_only = $i_perform_disk_space_count_only\n";
            }
        }
    }

    # Convert space re-claimed from byte to Megabyte and Gigabyte.

    if ($num_files_expired > 0) {
        $total_Megabytes_expired = $total_Bytes_expired / $Megabyte_to_Byte_conversion_factor;
        $total_Gigabytes_expired = $total_Bytes_expired / $Gigabyte_to_Byte_conversion_factor;
    }

    #
    # Print processing stats.
    #

    my $end_processing_time = localtime;
    log_this("INFO",$g_routine_name,"");
    log_this("INFO",$g_routine_name,"num_files_in_archive    = $num_files_in_archive");
    log_this("INFO",$g_routine_name,"i_num_minutes_to_keep   = $i_num_minutes_to_keep");

    log_this("INFO",$g_routine_name,"");

    if ($i_perform_disk_space_count_only eq "yes") {
        log_this("INFO",$g_routine_name,"Performed disk space reclaimed count only.  No files were purged from disk.");
    } elsif ($i_perform_disk_space_count_only eq "no") {
        log_this("INFO",$g_routine_name,"Actual statistics of disk space reclaimed.");
    }
    log_this("INFO",$g_routine_name,"");

    log_this("INFO",$g_routine_name,"num_files_expired       = $num_files_expired");
    log_this("INFO",$g_routine_name,"total_Bytes_expired     = $total_Bytes_expired");
    log_this("INFO",$g_routine_name,"total_Megabytes_expired = $total_Megabytes_expired");
    log_this("INFO",$g_routine_name,"total_Gigabytes_expired = $total_Gigabytes_expired");

    log_this("INFO",$g_routine_name,"");
    log_this("INFO",$g_routine_name,"begin_processing_time = $begin_processing_time");
    log_this("INFO",$g_routine_name,"end_processing_time   = $end_processing_time");

    # ---------- Close up shop ----------
    return ($o_status);

}

#------------------------------------------------------------------------------------------------------------------------

# A few global variables.

$g_debug = 0;
$g_routine_name = "purge_l2_holding_tank";

my $num_args = $#ARGV + 1;

# Do sanity check to make sure we have the correct number of parameters.

if ($num_args < 1 ) {
        print "usage: perl purge_l2_holding_tank.pl num_minutes_to_keep perform_disk_space_count_only\n";
        print "usage: perl purge_l2_holding_tank.pl 120                 no                            \n";
        exit(1);
}

# Get the input parameters.

# Set to default first and will get from argument list later.

my $DEFAULT_MINUTES_TO_KEEP = 120;  # Only delete files older than 2 hours.
my $i_num_minutes_to_keep = $DEFAULT_MINUTES_TO_KEEP;
my $i_perform_disk_space_count_only = "no";

# Reset to larger value if input is more then 2 hours, otherwise, keep to default of 2 hours.

if ($ARGV[0] > 120) {
    $i_num_minutes_to_keep  = $ARGV[0];
}

if ($ARGV[1] ne '') {
    $i_perform_disk_space_count_only = $ARGV[1];
}

# Calls subroutine to purge the holding tank.

purge_l2_holding_tank($i_num_minutes_to_keep, $i_perform_disk_space_count_only);

